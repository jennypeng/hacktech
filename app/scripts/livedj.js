// Generated by CoffeeScript 1.6.3
(function() {
  require(["$api/models", "$views/buttons"], function(models, buttons) {
    "use strict";
    var LiveDJ;
    LiveDJ = (function() {
      var self;
      self = {};
      self.Queue = function(callback) {
        var queue;
        queue = {};
        models.Playlist.createTemporary().done(function(playlist) {
          queue.spotify = playlist;
          return queue.spotify.load("tracks").done(function(loadedPlaylist) {
            return loadedPlaylist.tracks.clear().done(function() {
              if (callback) {
                return callback();
              }
            });
          });
        });
        queue.addFromURL = function(trackURL) {
          return queue.spotify.load("tracks").done(function(loadedPlaylist) {
            console.log("adding", trackURL, "to queue");
            return loadedPlaylist.tracks.add(models.Track.fromURI(trackURL));
          });
        };
        queue.addFromTrackEntry = function(trackEntry) {
          if (!trackEntry.hasUri) {
            console.warn("track entry", trackEntry, "has no URI");
          }
          return queue.addFromURL(trackEntry.uri);
        };
        queue.addFromTrackEntries = function(trackEntries) {
          var i, _results;
          i = 0;
          _results = [];
          while (i < trackEntries.length) {
            queue.addFromTrackEntry(trackEntries[i]);
            _results.push(i++);
          }
          return _results;
        };
        queue.toArray = function(callback) {
          return queue.spotify.load("tracks").done(function(loadedPlaylist) {
            return loadedPlaylist.tracks.snapshot().done(function(snapshot) {
              var arr, i;
              arr = [];
              i = 0;
              while (i < snapshot.length) {
                arr.push(snapshot.get(i).uri);
                i++;
              }
              console.log(arr);
              if (callback) {
                return callback(arr);
              }
            });
          });
        };
        queue.getTrackByIndex = function(i, callback) {
          return queue.spotify.load("tracks").done(function(loadedPlaylist) {
            return loadedPlaylist.tracks.snapshot().done(function(snapshot) {
              return callback(snapshot.get(i));
            });
          });
        };
        queue.removeByIndex = function(i, callback) {
          return queue.spotify.load("tracks").done(function(loadedPlaylist) {
            return queue.getTrackByIndex(i, function(track) {
              console.log("removing", track.uri, "from queue");
              loadedPlaylist.tracks.remove(track);
              if (callback) {
                return callback();
              }
            });
          });
        };
        queue.clear = function(callback) {
          return queue.spotify.load("tracks").done(function(loadedPlaylist) {
            loadedPlaylist.tracks.clear();
            if (callback) {
              return callback();
            }
          });
        };
        queue.clearAll = function(callback) {
          return queue.clear(function() {
            self.queueData.set([]);
            if (callback) {
              return callback();
            }
          });
        };
        return queue;
      };
      self.httpGet = function(theUrl) {
        var xmlHttp;
        xmlHttp = null;
        xmlHttp = new XMLHttpRequest();
        xmlHttp.open("GET", theUrl, false);
        xmlHttp.send(null);
        return xmlHttp.responseText;
      };
      self.search = function(query) {
        var res, response;
        response = self.httpGet("http://ws.spotify.com/search/1/track.json?q=" + query);
        res = JSON.parse(response);
        if (res.tracks[0]) {
          return res.tracks[0].href;
        }
      };
      self.updateInputIfNecessary = function(selector, value) {
        var $el;
        $el = $(selector);
        if ($el.val() !== value) {
          $el.val(value);
        }
        $el.addClass("flash");
        return setTimeout((function() {
          return $el.removeClass("flash");
        }), 0);
      };
      self.roomName = null;
      self.songData = null;
      self.indexData = null;
      self.queueData = null;
      self.queue = null;
      self.index = -1;
      self.getFirebase = function(room, path) {
        return new Firebase("https://livedj01.firebaseio.com/rooms/" + room + "/" + path);
      };
      self.changeRoom = function(roomName) {
        if (self.songData) {
          self.songData.off();
        }
        if (self.queueData) {
          self.queueData.off();
        }
        self.queue = new self.Queue(function() {
          self.songData.on("value", self.onSongDataChange);
          self.queueData.on("child_added", function(snapshot) {
            var newTrackEntry;
            newTrackEntry = snapshot.val();
            console.log("child_added", newTrackEntry);
            if (!newTrackEntry.hasMetadata) {
              self.updateTrackMetadata(newTrackEntry.uri, function(track) {
                newTrackEntry.title = track.title;
                newTrackEntry.image = track.image;
                newTrackEntry.artist = (track.artist ? track.artist : null);
                newTrackEntry.album = (track.album ? track.artist : null);
                newTrackEntry.hasMetadata = true;
                return snapshot.ref().set(newTrackEntry);
              });
            }
            return self.queue.addFromTrackEntry(newTrackEntry);
          });
          return self.playFromQueueIfNecessary();
        });
        roomName = roomName.toLowerCase();
        self.songData = self.getFirebase(roomName, "song");
        self.indexData = self.getFirebase(roomName, "index");
        self.queueData = self.getFirebase(roomName, "queue");
        self.updateInputIfNecessary("#roominput", roomName);
        $("#roomname").text(roomName);
        self.roomName = roomName;
        return console.log("room changed to " + roomName);
      };
      self.onSongDataChange = function(snapshot) {
        var data, trackURL;
        console.warn("onSongDataChange is incomplete and currently unsupported");
        return;
        data = snapshot.val();
        if (!data || !data.uri) {
          return;
        }
        trackURL = data.uri;
        self.updateInputIfNecessary("#songinput", trackURL);
        console.log("Track URL updated:", trackURL);
        return models.player.load("track").done(function(loadedPlayer) {
          var prevTrackURL;
          if (loadedPlayer.track) {
            prevTrackURL = loadedPlayer.track.uri;
            if (!trackURL) {
              return console.warn("trackURL is empty, not doing play");
            }
            if (prevTrackURL === trackURL) {
              return console.warn("prevTrackURL == trackURL, not doing play");
            }
          }
          self.playSong(trackURL);
          return self.lastTrackURL = trackURL;
        });
      };
      self.playFromQueueIfNecessary = function() {
        console.log("playFromQueueIfNecessary");
        return models.player.load(["context", "index"]).always(function(player) {
          var playerContext, queueContext;
          playerContext = (player.context ? player.context.uri : null);
          queueContext = (self.queue.spotify ? self.queue.spotify.uri : null);
          console.log("currently playing from", playerContext, player.index, "should be playing from", queueContext, self.index);
          if (playerContext === queueContext) {
            self.syncIndex();
          }
          if (playerContext !== queueContext || player.index !== self.index) {
            console.log("asking to play from queue");
            models.player.playContext(self.queue.spotify, self.index);
          }
          return self.syncIndex();
        });
      };
      self.syncIndex = function() {
        return self.indexData.once("value", function(indexData) {
          var savedIndex;
          console.log("indexData.val() =", indexData.val(), ", self.index =", self.index);
          savedIndex = indexData.val();
          if (savedIndex >= 0) {
            self.index = savedIndex;
          } else if (!(self.index >= 0)) {
            console.log("old index not found, using 0");
            self.index = 0;
            self.indexData.set(0);
          }
          return console.log("indexData.val() =", indexData.val(), ", self.index =", self.index);
        });
      };
      self.playSong = function(trackURL, callback) {
        var track;
        console.log("playing", trackURL);
        track = models.Track.fromURI(trackURL);
        return models.player.playTrack(track);
      };
      self.inputToTrackURL = function(input) {
        var m;
        console.log("searching '" + input + "'");
        if (!input) {
          console.warn("empty input");
          return;
        }
        m = input.match(/spotify:track:(\w+)|open.spotify.com\/track\/(\w+)/);
        if (m) {
          return "spotify:track:" + m[1];
        }
        return self.search(input);
      };
      self.updateTrackMetadata = function(trackURL, callback) {
        var cont, done, track, trackInfo;
        console.log("updateTrackMetadata");
        done = [0];
        cont = function() {
          done[0]--;
          if (done[0] <= 0) {
            return callback(trackInfo);
          }
        };
        trackInfo = {
          uri: trackURL
        };
        track = models.Track.fromURI(trackURL);
        return track.load(["album", "artists", "image", "name"]).done(function(loadedTrack) {
          trackInfo.image = loadedTrack.image;
          trackInfo.title = loadedTrack.name;
          if (loadedTrack.album) {
            done[0]++;
            loadedTrack.album.load("name").done(function(loadedAlbum) {
              console.log("loaded album");
              trackInfo.album = loadedAlbum.name;
              return cont();
            });
          } else {
            trackInfo.album = null;
          }
          if (loadedTrack.artists && loadedTrack.artists[0]) {
            done[0]++;
            return loadedTrack.artists[0].load("name").done(function(loadedArtist) {
              console.log("loaded artist");
              trackInfo.artist = loadedArtist.name;
              return cont();
            });
          } else {
            return trackInfo.artists = null;
          }
        });
      };
      self.submitSong = function(e) {
        var search, trackEntry;
        search = $("#songinput").val();
        trackEntry = {
          search: search,
          hasUri: true,
          hasMetadata: false,
          uri: self.inputToTrackURL(search)
        };
        self.songData.set(trackEntry);
        $("#songinput").select();
        return e.preventDefault();
      };
      self.submitQueue = function(e) {
        var search, trackEntry;
        search = $("#queueinput").val();
        trackEntry = {
          search: search,
          hasUri: true,
          hasMetadata: false,
          uri: self.inputToTrackURL(search)
        };
        self.queueData.push(trackEntry);
        $("#queueinput").select();
        return e.preventDefault();
      };
      self.submitRoom = function(e) {
        self.changeRoom($("#roominput").val());
        $("#roominput").select();
        return e.preventDefault();
      };
      self.init = function() {
        self.changeRoom("welcometohacktech");
        $("#songinput").select();
        $("#submitRoom").click(self.submitRoom);
        $("#submitSong").click(self.submitSong);
        $("#submitQueue").click(self.submitQueue);
        $("#submitClear").click(function() {
          return self.queue.clearAll();
        });
        $("#submitPlay").click(self.playFromQueueIfNecessary);
        return models.player.addEventListener("change", function() {
          return models.player.load(["context", "index"]).done(function(player) {
            var playerContext, queueContext;
            playerContext = (player.context ? player.context.uri : null);
            queueContext = (self.queue.spotify ? self.queue.spotify.uri : null);
            if (playerContext === queueContext) {
              self.index = player.index;
              self.indexData.set(self.index);
              return self.queue.getTrackByIndex(self.index, function(track) {
                if (track) {
                  return self.songData.set({
                    uri: track.uri
                  });
                }
              });
            }
          });
        });
      };
      return self;
    })();
    return exports.LiveDJ = LiveDJ;
  });

}).call(this);
